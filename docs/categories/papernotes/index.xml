<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PaperNotes on Chang Liu&#39;s Blog</title>
    <link>http://changliu0828.github.io/categories/papernotes/</link>
    <description>Recent content in PaperNotes on Chang Liu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 05 Sep 2020 18:40:23 +0800</lastBuildDate>
    
	<atom:link href="http://changliu0828.github.io/categories/papernotes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>面包店算法, Lamport, 1974</title>
      <link>http://changliu0828.github.io/post/a-new-solution-of-dijkstras-concurrent-programming-problem/</link>
      <pubDate>Sat, 05 Sep 2020 18:40:23 +0800</pubDate>
      
      <guid>http://changliu0828.github.io/post/a-new-solution-of-dijkstras-concurrent-programming-problem/</guid>
      <description>Dijkstra互斥问题 在之前的文章中提到过Dijkstra于1965年提出的基于共享存储的临界区互斥访问问题。Dijkstra提出了基于对内存单元的原子性读写实现的方案。
然而，Lamport指出Dijkstra的方案会因为节点在临界区内失效而导致系统死锁。在其于1974年发表的文章A New Solution of Dijkstra&amp;rsquo;s Concurrent Programming Problem中，Lamport提出了完全基于软件实现的解决方案，被称为“面包店算法”。
面包店算法 ”面包店算法&amp;quot;模拟面包店内取号服务的模式，实现了先来先服务的的互斥访问。我们有如下说明，
 如果不同节点对同一内存单元并发读写，只有写会正确执行，读可能会读到不确定值。 节点失效时，其立即跳转至其非临界区并挂起。其后一段时间内读取其内存会返回不确定值，最终所有的读会返回0。 使用初始值为0的两个数组choosing[1:N] 和 number[1:N]，其中N为节点数量。 number[i] 的取值没有上限。 代码中 maximum 函数读到各个变量的值的顺序没有要求。 代码 L3 中的比较运算 (a,b)&amp;lt;(c,d) 可以视为 if a &amp;lt; c or if a = c and b &amp;lt; d。  1 2 3 4 5 6 7 8 9 10 11 12 13 14  begin integer j; L1: choosing[i] := 1; number[i] := 1 + maximum(number[1], ... , number[N]); choosing[i] := 0; for j = 1 step 1 until N do begin L2: if choosing[j] !</description>
    </item>
    
    <item>
      <title>分布式领域开山之作, Dijkstra, 1965</title>
      <link>http://changliu0828.github.io/post/solution-of-a-problem-in-concurrent-programming-control/</link>
      <pubDate>Thu, 03 Sep 2020 19:48:34 +0800</pubDate>
      
      <guid>http://changliu0828.github.io/post/solution-of-a-problem-in-concurrent-programming-control/</guid>
      <description>Edsger W. Dijkstra于1965年发表文章Solution of a Problem in Concurrent Programming Control，引出并发系统下的互斥(mutual exclusion)问题，自此开辟了分布式计算领域。Dijkstra在文中给出了基于共享存储原子性访问的解决方案只有十多行代码，但阅读起来较难以理解。在查阅若干资料后，总结了一种较为直观的解释方法，记录于此。
问题 考虑N个节点(进程)，每个都在运行一个无限循环的程序。每轮循环当中都存在一个临界区(critical section)。我们需要设计算法控制多个计算机中，同时只有一台可以进入其临界区，并需要满足下列条件，
 所有的节点是对称(symmetrical)的，即我们不能引入类似于“1号节点优先于2号节点”的静态优先级配置。 各个节点的运行速度可能不同，同一个节点在不同时刻的运行速度也可能不同。 任意节点在临界区外停止运行，不应引起系统的死锁。 如果多个节点想要访问临界区，必须在有限时间内决策出哪个节点优先访问。  各个节点之间可以通过共享存储(common store)通信，共享存储提供以字(word)为单位的原子性读写。
当今现在，在基于共享内存通信的单机多进程上，我们可以很方便的使用基于TAS(Test&amp;amp;Set)或的CAS(Copy&amp;amp;Swap)实现的互斥锁mutex来实现临界区互斥访问。然而，在只有对内存单元原子读写的条件下，如何完成互斥访问呢？Dijkstra给出了他的解法。
解法与证明 在共享存储上，Dijkstra使用了两个长度为N的布尔数组，和一个整数。
1  Boolean array b, c[1:N]; integer K   其中，$k$ 满足 $1 \leqslant k \leqslant N$，$b[i]$ 和 $c[i]$ 只被节点 $i$ 修改，且初始值为true。对于第 $i$ 个节点$(1 \leqslant i \leqslant N)$，执行下面的代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  integer j Li0: b[i] := false Li1: if k !</description>
    </item>
    
  </channel>
</rss>