<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码笔记 on Chang Liu&#39;s Blog</title>
    <link>http://changliu0828.github.io/categories/%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 源码笔记 on Chang Liu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 23 Sep 2020 16:28:30 +0800</lastBuildDate>
    
	<atom:link href="http://changliu0828.github.io/categories/%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>libco源码笔记(3)自动切换</title>
      <link>http://changliu0828.github.io/post/libco-auto/</link>
      <pubDate>Wed, 23 Sep 2020 16:28:30 +0800</pubDate>
      
      <guid>http://changliu0828.github.io/post/libco-auto/</guid>
      <description>在之前的文章libco源码笔记(2)显示切换中，我们介绍了libco提供的显示协程切换接口，并讨论了协程池的使用。本文讨论libco提供的自动切换相关函数接口。建议配合我自己的注释版本阅读本文。
自动切换的背景 李方源的libco分享$^{[2]}$中讲到，使用libco之前，微信的大多的网络通信使用同步IO接口。为了快速改造现有业务代码，libco以hook系统调用的形式，提供了协程基础上的poll，read，write等原语。利用协程的特性，原来阻塞的系统调用可以达到非阻塞的效果。
超时管理 libco为了对统一网络IO，条件变量需要超时管理的事件，实现了基于时间轮(timing wheel)的超时管理器。在介绍其对系统调用的hook前，容我们先铺垫一些关于这个超时管理器的实现。
如下图1所示，时间轮为图中深红色的轮状数组，数组的每一个单元我们称为一个槽(slot)。单个slot里存储一定时间内注册的事件列表（图中黄色链表）。在libco中，单个slot的精度为1毫秒，整个时间轮由60000个slot组成，对应的整个时间轮覆盖60秒的时间。libco中关于时间轮的接口函数主要是下面两个。
AddTimeout通过计算当前时间allNow与时间轮起始时间ullStart的差，插入对应slot。特别注意的是当超时事件大于轮长60秒时，libco将这种事件插入到“最后一个&amp;quot;slot。
TakeAllTimeout通过计算当前时间allNow与时间轮起始时间ullStart的差，得出对应slot，遍历从起始索引ullStartIdx所指slot到其的所有slot中的超时项并移动到结果链表apResult中。
至此，我们看到通过时间轮，libco得以高效的完成对超时事件的管理。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* 在时间轮中插入新项 * @param * apTimeout :时间轮结构 * apItem :新的超时项 * allNow :当前事件(timestamp in ms) * @return :0成功, else失败行数 */ int AddTimeout( stTimeout_t *apTimeout,stTimeoutItem_t *apItem ,unsigned long long allNow ); /* 在时间轮中取出所有超时项 * @param * apTimeout:时间轮结构 * allNow :当前时间(timestamp in ms) * apResult :超时事件结果链表 */ inline void TakeAllTimeout( stTimeout_t *apTimeout,unsigned long long allNow,stTimeoutItemLink_t *apResult );     图1.</description>
    </item>
    
    <item>
      <title>libco源码笔记(2)显式切换</title>
      <link>http://changliu0828.github.io/post/libco-manual/</link>
      <pubDate>Tue, 22 Sep 2020 16:18:17 +0800</pubDate>
      
      <guid>http://changliu0828.github.io/post/libco-manual/</guid>
      <description>在之前的文章libco源码笔记(1)协程与上下文切换中，我们介绍了协程的基本概念以及libco中的上下文切换核心代码。本文libco提供的显式切换相关函数接口，与此相对的通过hook系统调用提供的自动切换机制在后续文章中介绍。建议配合我自己的注释版本阅读本文。
libco主要结构体 首先我们介绍一些libco中的三个核心结构体，下图1中描述了三者的关系，
coctx_t 保存协程切换时所需的上下文信息，详尽的说明请参考libco源码笔记(1)协程与上下文切换，此处不再说明。
stCoRoutine_t 协程主要结构体，包含单个协程的全部信息，如协程启停状态，执行函数，上下文信息，共享栈信息等。
stCoRoutineEnv_t 1  static __thread stCoRoutineEnv_t* gCoEnvPerThread = NULL; //协程运行环境 __thread:线程私有   线程私有全局静态变量，包含全局协程环境信息，如协程调用栈，epoll句柄等。其中pCallStack为当前线程中的协程调用栈，由于libco为非对称协程
  图1. libco核心结构
  libco显示切换函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 协程创建接口 * @param * co :协程主结构体二级指针 * attr :协程可配置属性, 包括栈大小、共享栈地址 * pfn :协程调用函数 * arg :协程调用函数参数 * @return :0 */ int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,pfn_co_routine_t pfn,void *arg ) { if( !</description>
    </item>
    
    <item>
      <title>libco源码笔记(1)协程与上下文切换</title>
      <link>http://changliu0828.github.io/post/libco-coroutine/</link>
      <pubDate>Fri, 11 Sep 2020 15:08:21 +0800</pubDate>
      
      <guid>http://changliu0828.github.io/post/libco-coroutine/</guid>
      <description>本文结合微信高性能开源协程库libco，总结了协程相关的问题与解决方案。libco源码注释不多，这里附上我自己的注释版本，建议配合阅读。此外，文中的代码及解释均运行于x86-32位下，64位下的情况略有不同，篇幅有限不再赘述。
回调地狱 在正式开始探讨正题之前，容我们简单回顾下协程之所以产生的原因。
起初，如下图1(a)中所示，我们的系统中有源源不断的任务(图中task)需要处理。为此我们编写了一个服务端程序。这个程序以单进程方式运行(图中process)，并不断获取任务（图中loop）。对于获取到的每个任务，调用处理函数 f() 完成具体处理逻辑。特别的，对于函数 f() 来讲，代码片段 g() 消耗了比较长的时间。但尽管如此，系统外部任务的产生频率还是比 f() 的运行时间低，即整个系统对任务的消费能力高于任务的生产能力，此时我们的服务运转正常。
然而随着业务的发展，我们单位时间内接受的任务越来越多，(a)中的单进程服务模式已经无法及时消费任务。为此，如下图(b)中所示，我们可以将功能较为独立，消耗资源较大的 g() 部分抽离为单独的进程。原进程使用异步远程调用方式 call_g() 调用g()，并注册回调函数 g_callback() 处理 g() 的返回。在编码时，我们需要将原有顺序的编程方式改为调用部分加回调部分的编程方式。
  图1
  虽然异步的编程方式提高了系统的吞吐量，减少了耦合度，但如下图展示的那样，完整的顺序执行代码片段被分隔成了若干代码片段。在代码相对复杂，需要远程调用较多的时候，代码的可维护性急剧下降，我们称这种现象为回调地狱(callback hell)。
  图2. 同步与异步编程下的代码片段
  何为协程 那么如何解决回调地狱，在保持异步执行的情况下，将支离破碎的代码段恢复成我们所熟悉的顺序执行呢？我们知道c/c++的程序执行时，运行现场的几乎全部信息都是通过栈帧(stack frame)和寄存器的保存的，如果我们在远程调用阻塞时，人为的将程序执行时的上下文保存，让出CPU，并在远程调用返回后加载上下文，就可以在一个函数栈中完成异步过程。我们称这种机制为协程(coroutine)。与熟悉的进程/线程切换类似，协程是用户自发的上下文切换和管理机制，所以也常被称为“用户态线程”。
  图3. 协程库的职责
  协程的上下文与切换 那么需要我们手动保存和加载的运行时“上下文”都包含哪些内容呢？以下面的 main 函数调用 sum 函数为例，
1 2 3 4 5 6 7 8 9 10  int sum(int x, int y) { int z = x + y; return z; } int main() { int a = 1; int b = 10; int c = sum(a, b); return 0; }   在使用  g++ -m32 -s sum.</description>
    </item>
    
  </channel>
</rss>