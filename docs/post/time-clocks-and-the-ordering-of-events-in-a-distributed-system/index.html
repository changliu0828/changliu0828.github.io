<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Time, Clocks, and the Ordering of Events in a Distributed System, Lamport, 1978 | Chang Liu&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <script src="https://kit.fontawesome.com/a0e5d04d0b.js" crossorigin="anonymous"></script>


  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">主页</a></li>
      
      <li><a href="/categories/">分类</a></li>
      
      <li><a href="/tags/">标签</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h2><span class="title">Time, Clocks, and the Ordering of Events in a Distributed System, Lamport, 1978</span></h2>

<h3 class="date">2020/10/06</h3>
</div>


<aside class="toc">
<nav id="TableOfContents">
  <ul>
    <li><a href="#1-问题">1. 问题</a></li>
    <li><a href="#2-时间是什么">2. 时间是什么</a></li>
    <li><a href="#3-分布式系统">3. 分布式系统</a></li>
    <li><a href="#4-happened-before-偏序关系">4. Happened Before 偏序关系</a></li>
    <li><a href="#5-逻辑时钟">5. 逻辑时钟</a></li>
    <li><a href="#6-全序关系">6. 全序关系</a></li>
    <li><a href="#7-物理时钟">7. 物理时钟</a>
      <ul>
        <li><a href="#71-系统之外">7.1 系统之外</a></li>
        <li><a href="#72-物理时钟实现">7.2 物理时钟实现</a></li>
      </ul>
    </li>
    <li><a href="#8附录">8.附录</a>
      <ul>
        <li><a href="#81-全序关系的应用互斥访问">8.1 全序关系的应用：互斥访问</a></li>
        <li><a href="#82-物理时钟定理证明">8.2 物理时钟定理证明</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>



<main>
<p>本篇文章总结学习了Lamport于1978年发表在 <em>Communications of the ACM</em> 上的论文 <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf">Time, Clocks, and the Ordering of Events in a Distributed System</a>，文章对分布式系统中的时间，时钟等概念做了深入的讨论，提出了“Happened Before”，“逻辑时钟”，“物理时钟”，“State Machine”等重要概念与算法，是分布式领域不能不读的经典论文。</p>
<h1 id="1-问题">1. 问题</h1>
<p>在进入正题之前，首先让我们考虑如下问题：</p>
<ul>
<li>某一人做了某事 $A$ 并看了其手表，其读数为“2020/10/06 13:00”。他声称 $ A $ 发生于“2020/10/06 13:00”。</li>
<li>另一人做了某事 $B$ 并看了其手表，其读数为“2020/10/06 13:05”。他声称 $B$ 发生于“2020/10/06 13:05”。</li>
</ul>
<p>假设两人都是诚实的，我们能说 $A$ 发生在 $B$ 之前吗？显然，由于我们并不知道两人的手表时间是否“准确”，所以不能准确地判断出孰先孰后。那么如果问题变成下面这样，结论又是如何呢？</p>
<ul>
<li>某一人做了某事 $A$ ，并看了其手表，读数为“2020/10/06 13:00”。他声称 $ A $ 发生于“2020/10/06 13:00”。</li>
<li>此人打了一通电话给另一人。</li>
<li>第二个人在通话完毕后，做了某事 $B$ 并看了其手表，其读数为“2020/10/06 12:55”。他声称 $B$ 发生于“2020/10/06 12:55”。</li>
</ul>
<p>由此可见，我们通常使用的时钟读数、时间戳等概念并不能准确地刻画出事件发生的先后顺序。而在分布式系统中，事件发生的先后常常扮演着各种算法的“关键角色”。那么我们如何准确地刻画这种顺序，或是设计我们的时钟，从而避免上面例子中的问题呢？</p>
<h1 id="2-时间是什么">2. 时间是什么</h1>
<blockquote>
<p>The concept of time is fundamental to our way of thinking. It is derived from the more basic concept of the order in which events occur.</p>
</blockquote>
<p>时间的定义对于分布式领域关于“事件发生先后”、“并发”等概念的认识至关重要。Lamport在文中指出，时间是由更加基本的概念“事件发生的顺序”衍生出来的。例如我们说某件事在13:00发生，其实是在说这件事发生在我们读到时钟上的读数为13:00之后，13:01之前。由此可见，时钟其实是对连续的时间进行了离散化的“编号”。</p>
<h1 id="3-分布式系统">3. 分布式系统</h1>
<p>本文中讨论的分布式系统，是由若干空间上分离的process组成。同一process上的事件顺序串行发生，process之间通过收发消息进行通信。这里的process可以是若干独立的计算机，独立的进程，亦或是一台计算机内独立的硬件模块。在后文中我们我们统称process为“节点”。特别的，各个节点之间的通信延迟与单个节点内部事件发生的频率相比，是不可忽略的。</p>
<h1 id="4-happened-before-偏序关系">4. Happened Before 偏序关系</h1>
<p>对于一个分布式系统中的若干事件，我们定义“happened before”关系，用&quot;$\rightarrow$&quot;标识。其满足如下三个条件，</p>
<ul>
<li>(1) 如果 $a$ 和 $b$ 是在相同节点上的两个事件，$a$ 在 $b$ 之前发生，则有 $a \rightarrow b$ 。</li>
<li>(2) 如果事件 $a$ 表示某个节点发送某条消息，$b$ 是另一个节点接受这条消息，则有 $a \rightarrow b$ 。</li>
<li>(3) 如果有 $a \rightarrow b$ 且 $b \rightarrow c$ ，则有 $a \rightarrow c$ 。</li>
</ul>
<p>当且仅当 $a \nrightarrow b, b \nrightarrow a$ 时，我们称两个事件为<strong>并发的(concurrent)</strong>。</p>
<p>此外，我们规定 $\rightarrow$ 为非自反关系，即 $a \nrightarrow a$ 。显然，说一件事发生在自己“之前”并无任何意义。</p>
<p>为了直观的描述这一关系，Lamport引入了如下图所示的“时空图”，图中垂直方向自下而上为时间发生顺序，水平方向为空间上的不同节点。图中的黑色圆点表示事件，波浪线箭头表示通信消息。</p>
<p>回顾上面的&quot;happened before&quot;关系, 我们不难在图中找到若干满足条件的事件对，例如 $p_1 \rightarrow r_4$，其由 $ p_1 \rightarrow q_2 \rightarrow q_4 \rightarrow r_3 \rightarrow r_4$ 推导而来。</p>
<p>图中亦有若干并发的事件，例如 $p_3$ 和 $q_3$，虽然在图中我们能看到 $p_3$ 发生的物理时间(physical time)晚于 $q_3$，但对于系统中的节点来说，他们并不知道谁先谁后。</p>
<figure>
    <img src="/image/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/Fig1.jpg"
         alt="图1. space-time diagram" width="70%"/> <figcaption>
            <p>图1. space-time diagram</p>
        </figcaption>
</figure>

<h1 id="5-逻辑时钟">5. 逻辑时钟</h1>
<blockquote>
<p>a clock is just a way of assigning a number to an event.</p>
</blockquote>
<p><strong>时钟仅仅是对事件的发生予以编号而已。</strong> 更加准确地讲，对于每一个节点 $P_i$ 我们定义时钟 $C_i$ 为一个函数，它为任意的事件 $a$ 赋值编号为 $C_i \langle a \rangle$。对整个系统时钟来讲，任意事件 $b$ 的发生时间标记为 $  C \langle b \rangle $，如果其发生在节点 $P_j$ 上，则 $ C \langle b \rangle =  C_j \langle b \rangle$。这里的时钟我们看做是系统内部的逻辑时钟，而非物理时钟，其标识与计数方法无需与物理时间一致。为了满足上文的&quot;happened before&quot;偏序关系，我们设计的逻辑时钟需要满足如下的Clock Condition.</p>
<p><strong>Clock Condition.</strong> 对于系统中的任意事件 $a, b$：如果 $ a \rightarrow b$，则 $C \langle a \rangle &lt; C \langle b \rangle$。</p>
<ul>
<li>C1. 如果 $a$ 和 $b$ 是在相同节点 $P_i$ 上的两个事件，$a$ 在 $b$ 之前发生，则有 $C_i \langle a \rangle &lt; C_i \langle b \rangle$。</li>
<li>C2. 如果事件 $a$ 表示节点 $P_i$ 发送某条消息，$b$ 表示节点 $P_j$ 接受这条消息，则有$ C_i \langle a \rangle &lt; C_j \langle b \rangle $。</li>
</ul>
<p><strong>特别的，Clock Condition的逆命题&quot;如果 $C \langle a \rangle &lt; C \langle b \rangle$，则 $ a \rightarrow b$&quot;并不成立。</strong> 因为它要求并发的事件必须具有相同的逻辑时间。例如图1中的 $p_2,p_3$ 都与 $q_3$ 为并发关系，但由 C1 有 $C \langle p_2 \rangle &lt; C \langle p_3 \rangle$，则必然有 $C \langle q_3 \rangle \neq C \langle p_2 \rangle$ 或 $C \langle q_3 \rangle \neq C \langle p_3 \rangle$，与并发关系矛盾。</p>
<p>对于逻辑时钟，我们可以想象单个节点内不断发生着“tick”事件，例如在同一节点 $P_i$ 内连续发生的 $a, b$ 两个事件，有 $C_i \langle a \rangle = 4, C_i \langle b \rangle = 7$，那么在这两个事件之间发生了编号为 $5,6,7$ 的 tick 事件。于是我们可以在时空图中加入类似下图虚线所示的&quot;tick line&rdquo;。根据 C1 我们可以得到，在同一节点内的连续两个事件之间，至少要有一条 tick line。 根据 C2 我们可以得到，每一条消息必须穿过至少一条 tick line。</p>
<figure>
    <img src="/image/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/Fig2.png"
         alt="图2" width="70%"/> <figcaption>
            <p>图2</p>
        </figcaption>
</figure>

<p>为了更方便理解，我们也可以在保证事件和消息的偏序关系下，将 tick line 绘制成如下图中等价的水平线的形式。</p>
<figure>
    <img src="/image/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/Fig3.png"
         alt="图3" width="70%"/> <figcaption>
            <p>图3</p>
        </figcaption>
</figure>

<p>对于单个节点上的逻辑时钟算法的实现，我们有如下的实现规则（Implementation Rule）：</p>
<ul>
<li>IR1. 每个节点 $P_i$ 在任意连续的两个事件之间都要增加 $C_i$ 。</li>
<li>IR2. (a) 如果事件 $a$ 表示节点 $P_i$ 发送消息 $m$ ，那么 $m$ 中包含时间戳 $T_m=C_i \langle a \rangle $。(b) 当收到消息 $m$ 时，进程 $P_j$ 设置当前时间 $C_j$ 为 $ C_j'$，使得 $C_j&rsquo; &gt;= C_j$ 且 $C_j&rsquo; &gt; Tm$ 。</li>
</ul>
<p>在实践中，当我们收到某条消息后，应当先执行 IR2 修改时间，再执行具体事件，从而保证 <strong>Clock Condition</strong>。</p>
<h1 id="6-全序关系">6. 全序关系</h1>
<p>利用逻辑时钟，我们可以对整个系统中的事件进行全序(total order)排序。我们首先根据事件发生的时间对其排序。对于发生时间相同的事件，我们引入对于所有节点的预先优先级 $\prec$，这里的优先级可以是根据 id 排序等任意规则。</p>
<p>更加严谨的说，我们定义全序关系 $\Rightarrow$。对于发生在节点 $P_i$ 的事件 $a$ 和发生在节点 $P_j$ 的事件 $b$，有 $ a \Rightarrow b $ 当且仅当 (i) $ C_i \langle a \rangle &lt; C_j \langle b \rangle $ 或 (ii) $C_i \langle a \rangle = C_j \langle b \rangle$ 且 $P_i \prec P_j$。</p>
<p>这里由 <strong>Clock Condition</strong> 我们可以看到，凡是满足偏序关系 $\rightarrow$ 的，一定也满足全序关系 $\Rightarrow$。</p>
<figure>
    <img src="/image/Time-Clocks-and-the-Ordering-of-Events-in-a-Distributed-System/partial-total.png"
         alt="图4. 偏序与全序关系" width="40%"/> <figcaption>
            <p>图4. 偏序与全序关系</p>
        </figcaption>
</figure>

<h1 id="7-物理时钟">7. 物理时钟</h1>
<h2 id="71-系统之外">7.1 系统之外</h2>
<p>在全序关系下，由于系统之外的一些事件，使得我们有时会遇到一些反常行为。</p>
<p>考虑下面这种情况，某人在节点A上触发了事件A，随后打电话给另一个人。此人接到电话后在节点B上触发事件B。由于整个系统对于系统之外的事件“打电话”毫不知情，则有可能出现 $B \Rightarrow A$ 的情况。</p>
<p>我们可以定义系统中的所有事件集合为 $\varphi$。系统中的事件与外部事件的合集为 $\underline{\varphi}$。$\underline{\rightarrow}$ 为 $\underline{\varphi}$ 上的 happened before 关系。在上面的例子中，我们有 $A \underline{\rightarrow} B$，但 $A \nrightarrow B$。</p>
<p>显然没有任何算法能够不利用外部信息，仅凭 $\varphi$ 就能保证 $\underline{\rightarrow}$ 关系。在此，为了能够确保$A \rightarrow B$，有如下两种方案，</p>
<ol>
<li>显式的引入外部信息。例如 $A$ 事件发生的逻辑时间为 $T_A$，在接到电话后，显式的告知系统 $B$ 的发生时间应大于 $T_A$。</li>
<li>构建满足如下<strong>Strong Clock Condition</strong> 的系统。</li>
</ol>
<p><strong>Strong Clock Condition.</strong> 对于 $\varphi$ 中的任意事件 $a, b$：如果$ a \underline{\rightarrow} b$ 则 $C \langle a \rangle &lt; C \langle b \rangle$。</p>
<p>显然相较于方案1，<strong>Strong Clock Condition</strong>才是我们希望的方案。下面具体介绍如何实现满足<strong>Strong Clock Condition</strong>的物理时钟。</p>
<h2 id="72-物理时钟实现">7.2 物理时钟实现</h2>
<p>令 $C_i(t)$ 表示时钟 $C_i$ 在物理时间 $t$ 读到的读数。在此，为了数学上的方便起见，我们认为 $C_i$ 对于 $t$ 是连续可微的。则 $dC_i(t)/dt$ 表示时钟在时间 $t$ 运行的速率。</p>
<p>为了使 $C_i$ 的运行速率与真实物理时钟相近，对于所有的 $t$，我们必须使得 $dC_i(t)/dt \approx 1$。更严谨的讲，我们需要满足如下条件，</p>
<ul>
<li>PC1. 存在一个常数 $\kappa \ll 1$，对于所有的 $i$ ，有 $| dC_i(t)/dt - 1 | &lt; \kappa$。对于典型的晶控时钟(crystal controlled clock)，$\kappa \leq 10^{-6}$。</li>
</ul>
<p>除了保证单个时钟运行准确之外，各个时钟之间的误差也不能太大。它们必须保证实时同步，进而确保对于所有的 $i,j,t$，有 $C_i(t) \approx C_j(t)$</p>
<ul>
<li>PC2. 对于所有的 $i, j$：$|C_i(t) - C_j(t)| &lt; \epsilon$。直观来讲即 Fig2 中的单条 tick line 高度差不能太大。</li>
</ul>
<p>对于 PC2，由于累计误差（accumulated error）的存在，两个完全独立运行的时钟必然会误差越来越大。因此我们需要某种算法对不同节点上的时钟进行对时。</p>
<p>首先我们假设我们的时钟满足<strong>Clock Condition.</strong>，这样我们只需考虑在 $\underline{\varphi}$ 中 $a \nrightarrow b$ 的情况。不难发现，此时 $a$ 与 $b$ 必然发生在不同的节点上。</p>
<p>令 $\mu$ 小于节点间的最小通信时延。即事件 $a$ 发生于物理时间 $t$，事件 $b$ 发生于另一节点。若 $ a\underline{\rightarrow} b$，则 $b$ 最早发生于 $t + \mu$。通常我们可以设定 $\mu$ 为节点间的最小距离除以光速。</p>
<p>为了避免上文中的反常情况，我们必须保证对于任意的 $i, j$ 和 $t$ ，有 $C_i(t + \mu) - C_j(t) &gt; 0$。通过PC1. 我们有 $C_i(t + \mu) - C_j(t) &gt; (1- \kappa)\mu$。结合PC2. 我们可以推导出如果 $\epsilon/(1 - \kappa) \leq \mu$， 则能够保证 $C_i(t + \mu) - C_j(t) &gt; 0$，从而保证<strong>Strong Clock Condition</strong>。</p>
<p>对于一条发送于物理时间 $t$ ，接收于物理时间 $t'$ 的消息 $m$。我们定义消息的总延迟（total delay） $ v_m = t&rsquo; - t$。接受消息的节点当然不知道 $v_m$ 的值，但是它可以知道这条消息的最小延迟（minimum delay） $\mu_m$， $\mu_m \geq 0$ 且 $\mu_m \leq v_m$。我们称 $\xi_m = v_m - \mu_m$ 为不可预测延迟（unpredictable delay）。</p>
<p>对于单个节点上的物理时钟算法的实现，我们有如下的实现规则（Implementation rule）：</p>
<ul>
<li>IR1&rsquo;. 每个节点 $P_i$ 在物理时间 $t$ 没有收到任何消息，那么 $C_i$ 在 $t$ 时刻可微，且 $dC_i(t)/dt &gt; 0$。</li>
<li>IR2&rsquo;. (a) 如果 $P_i$ 在物理时间 $t$ 发送消息 $m$ ，那么 $m$ 中包含时间戳 $T_m=C_i(t) $。(b) 当在物理时间 $t'$ 收到消息 $m$ 时，进程 $P_j$ 设置当前时间 $C_j(t&rsquo;) = max(C_j(t&rsquo; - 0), T_m + \mu_m)$。其中$C_j(t&rsquo; - 0) = \underset{\delta \rightarrow 0}{ lim }C_j(t&rsquo;-|\delta|)$。</li>
</ul>
<p>为了满足如上的实现规则，我们令 $\tau$ 为两个节点之间的最低通信间隔，即对于任意时间 $t$ 到 $t + \tau$，$P_i$ 至少应该发送一条消息给 $P_j$。</p>
<p><strong>定理</strong>：假设系统为一个遵循IR1&rsquo;.和IR2&rsquo;.，且直径为 $d$ 的强连通图。对于任意的消息 $m$，总有$\mu_m \leq \mu$，其中$\mu$ 为某个特定常数。 (a) PC1 总是成立。 (b) 存在常数 $\tau$ 和 $\xi$，系统中每条边上，每$\tau$秒，就会转发一条不可预测延迟最大为 $\xi$ 的消息。则PC2. 满足于，对于所有的 $t\gtrapprox t_0 + \tau d$，$\epsilon \approx d(2\kappa\tau + \xi)$，假设$\mu + \xi \ll \tau$。其证明见于<a href="#82%E7%89%A9%E7%90%86%E6%97%B6%E9%92%9F%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E">附录8.2</a>。</p>
<h1 id="8附录">8.附录</h1>
<h2 id="81-全序关系的应用互斥访问">8.1 全序关系的应用：互斥访问</h2>
<h2 id="82-物理时钟定理证明">8.2 物理时钟定理证明</h2>
</main>

<div class="post-comment">
    
<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
  new Valine({
    el: '#vcomments' ,
    appId: 'zNMMLLQ0MYK2AKAgq6nC93gV-gzGzoHsz',
    appKey: 'KfJ8vAFRca4uVeQWMNljT07B',
    notify: 'false', 
    verify: 'false', 
    avatar:'mm', 
    placeholder: '...',
    visitor: 'true',
    lang: 'en'
  });
</script>

</div>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  © <a href="www.changliu.me">Chang Liu</a> 2020 | <a href="mailto:changliu0828@gmail.com">Contact</a>
  
  </footer>
  </body>
</html>

