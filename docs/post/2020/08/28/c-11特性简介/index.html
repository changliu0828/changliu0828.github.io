<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>c&#43;&#43;11特性简介 | Chang Liu&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">c++11特性简介</span></h1>

<h2 class="date">2020/08/28</h2>
</div>

<main>
<p>C++自1985年发行以来成为了世界上最成功的的编程语言之一。本文总结了C++11引入的部分重要特性，并逐一举例说明。完整特性与编译器支持请参考<a href="https://en.cppreference.com/w/cpp/compiler_support">这里$^{[1]}$</a>。</p>
<h1 id="部分特性与示例">部分特性与示例</h1>
<h2 id="1-右值引用rvalue-references">1. 右值引用(rvalue references)</h2>
<p>在C语言中，左值与右值原是即为简单的概念。凡是既可以出现在赋值语句两边的称为左值，只能出现在赋值语句右边的称为右值。例如下面的代码中，<code>a</code>和<code>b</code>是左值，<code>42</code>和<code>a + b</code>是右值。如果右值出现在赋值语句左边，则会产生一个编译错误。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span> a = <span style="color:#099">42</span>;
<span style="color:#0aa">int</span> b = a;
<span style="color:#099">42</span> = a + b; <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span>a + b = a;  <span style="color:#aaa;font-style:italic">//compile error
</span></code></pre></div><p>另一种说法是，左值是哪些能被<code>&amp;</code>操作符取到地址的值，右值是通过左值运算得出的临时结果或一些字面常量。把上面的代码编译成汇编语言就一目了然了，下面的代码中左值<code>a</code>和<code>b</code>都在栈上分配了空间，分别是<code>-4(%rbp)</code>和<code>-8(%rbp)</code>，而右值<code>42</code>只是一个立即数，<code>a + b</code>则是<code>addl</code>的两个参数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#0a0">movl</span>  <span style="color:#a00">$42</span>, -<span style="color:#099">4</span>(<span style="color:#a00">%rbp</span>)   <span style="color:#aaa;font-style:italic">;int a = 42;
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#a00">movl</span>  -<span style="color:#099">4</span>(<span style="color:#a00">%rbp</span>), <span style="color:#a00">%eax</span>  
<span style="color:#a00">movl</span>  <span style="color:#a00">%eax</span>, -<span style="color:#099">8</span>(<span style="color:#a00">%rbp</span>)
<span style="color:#0a0">movl</span>  -<span style="color:#099">8</span>(<span style="color:#a00">%rbp</span>), <span style="color:#a00">%eax</span>  <span style="color:#aaa;font-style:italic">;int b = a
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#a00">addl</span>  <span style="color:#a00">%eax</span>, -<span style="color:#099">4</span>(<span style="color:#a00">rbp</span>)<span style="color:#aaa;font-style:italic">;  ;a = a + b
</span></code></pre></div><p>使用引用是提高程序运行效率的常用手段，而在只提供左值引用的C++03时代，在某些场景下的引用并没有那么“好用”。下面的代码中，由于无法传递右值<code>Data()</code>的引用，我们不得不使用3行丑陋的代码来完成一个简单的工作。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
<span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span>Data double_data = Merge(Data(), Data()); 
<span style="color:#aaa;font-style:italic">//ok, but ugly
</span><span style="color:#aaa;font-style:italic"></span>Data data1;
Data data2;
Data double_data = Merge(data1, data2);
</code></pre></div><p>C++中，提供了右值引用操作符<code>&amp;&amp;</code>，于是我们增加支持右值引用的<code>Merge</code>，代码可以简化成，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
<span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp;&amp; data1, Data&amp;&amp; data2);
Data double_data = Merge(Data(), Data()); <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><p>然而，如果这时候我们想传入一个左值和一个右值，编译器就无法匹配对应的<code>Merge</code>了。此时需要使用<code>std::move</code>将左值<code>data1</code>转化为右值引用，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
<span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp;&amp; data1, Data&amp;&amp; data2);
Data data1;
Data double_data = Merge(data1, Data()); <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span>Data double_data = Merge(std::move(data1), Data()); <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><p>在C++03时代，我们可以通过<code>const</code>左值引用扩展右值的生命周期到引用销毁时刻，但其值<strong>不可被修改</strong>。通过右值引用，<strong>不仅可以延长右值的生命周期，其值也可以自由修改</strong>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">const</span> <span style="color:#0aa">int</span>&amp; a = <span style="color:#099">42</span>;
a = <span style="color:#099">43</span>; <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">int</span>&amp;&amp;b = <span style="color:#099">42</span>;
b = <span style="color:#099">43</span>; <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><h2 id="2-移动语义move-semantic">2. 移动语义(move semantic)</h2>
<p>移动语义旨在通过右值引用，实现资源的“移动&rdquo;，而非先拷贝再删除，节省拷贝开销。这里注意，原资源的释放是被要求，但不是必须的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Data(Data&amp;&amp; other) {
  _res = other._res;
  other._res = <span style="color:#00a">nullptr</span>;
}
</code></pre></div><h3 id="stdmove">std::move</h3>
<p>使用<code>std::move</code>可以将左值转为右值，从而方便使用移动语义。<strong>这里指的注意的是，将左值传入移动构造函数，会导致其值被释放。所以应当确保在调用移动构造后，改左值不被使用。</strong></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data::Data(<span style="color:#00a">const</span> Data&amp; other);
<span style="color:#00a">extern</span> Data::Data(Data&amp;&amp; other);
Data d1;
Data <span style="color:#0a0">d2</span>(d1); <span style="color:#aaa;font-style:italic">//d1 is lvalue, copy constructor
</span><span style="color:#aaa;font-style:italic"></span>Data <span style="color:#0a0">d2</span>(std::move(d1)); <span style="color:#aaa;font-style:italic">//std::move(d1) is rvalue, move constructor
</span></code></pre></div><p>另外一个值得注意的问题是，有些时候我们以为是一个移动构造，但其实执行的是拷贝构造，例如下面的<code>_str</code>其实执行的是<code>string</code>的拷贝构造，这是因为<strong>右值引用是一个左值</strong>，正确的做法是<code>_str = std::move(other._str)</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Data(Data&amp;&amp; other) {
  _str = other._str;
}
</code></pre></div><h2 id="3-完美转发perfect-forwarding">3. 完美转发(perfect forwarding)</h2>
<p>完美转发为可变参数模板函数提供了保持原有值语义的转发行为。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//模板参数的转发, OuterFunction接受左值引用
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T&gt;
<span style="color:#0aa">void</span> OuterFunction(T&amp; param) { 
  InnerFunction(param); 
}
OuterFunction(<span style="color:#099">5</span>); <span style="color:#aaa;font-style:italic">//编译错误，不能传递右值
</span></code></pre></div><p>为此，我们需要写一个支持右值引用的函数，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//模板参数的转发, OuterFunction接受左值引用
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T&gt;
<span style="color:#0aa">void</span> OuterFunction(T&amp;&amp; param) { 
  InnerFunction(param); 
}
OuterFunction(<span style="color:#099">5</span>); <span style="color:#aaa;font-style:italic">//OK
</span></code></pre></div><h2 id="4-智能指针">4. 智能指针</h2>
<p>C++11增加了三种智能指针，</p>
<ul>
<li><code>unique_ptr</code>；独占资源</li>
<li><code>shared_ptr</code>：共享资源，引用计数自动销毁</li>
<li><code>weak_ptr</code>：解决<code>shared_ptr</code>互相引用问题，不占用引用计数</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">unique_ptr&lt;string&gt; pu1(<span style="color:#00a">new</span> string (<span style="color:#a50">&#34;Hello&#34;</span>));
unique_ptr&lt;string&gt; pu2 = pu1; <span style="color:#aaa;font-style:italic">//ERROR
</span><span style="color:#aaa;font-style:italic"></span>
shared_ptr&lt;string&gt; ps1(<span style="color:#00a">new</span> string (<span style="color:#a50">&#34;Hello&#34;</span>)); <span style="color:#aaa;font-style:italic">//ps1.use_count() = 1
</span><span style="color:#aaa;font-style:italic"></span>ps2 = ps1;  <span style="color:#aaa;font-style:italic">//ps1.use_count() = 2
</span></code></pre></div><h2 id="5-lambda表达式lambda-expressions">5. lambda表达式(lambda expressions)</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">Point</span> {
  <span style="color:#0aa">int</span> x;
  <span style="color:#0aa">int</span> y;
};
vector&lt;Point&gt; v;
<span style="color:#aaa;font-style:italic">//c++98
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">int</span> <span style="color:#0a0">compByX</span>(<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.x &lt; p2.x; } 
<span style="color:#0aa">int</span> <span style="color:#0a0">compByY</span>(<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.y &lt; p2.y; } 
sort(v.begin, v.end(), compByX);
sort(v.begin, v.end(), compByY);
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>sort(v.begin, v.end(), [](<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.x &lt; p2.x });
sort(v.begin, v.end(), [](<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.y &lt; p2.y });
</code></pre></div><h2 id="6-auto类型变量auto-typed-variables">6. auto类型变量(auto-typed variables)</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++98
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v;
<span style="color:#00a">for</span> (std::vector&lt;<span style="color:#0aa">int</span>&gt;::iterator it = v.begin(); it != v.end(); ++ it) {
  std::cout &lt;&lt; *it &lt;&lt; endl;
}
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#00a">auto</span> it = v.begin(); it != v.end(); ++ it) {
  std::cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre></div><h2 id="7-基于range的for循环range-based-for">7. 基于range的for循环(Range-based for)</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v;
<span style="color:#00a">for</span> (std::vector&lt;<span style="color:#0aa">int</span>&gt;::iterator it = v.begin(); it != v.end(); ++ it) {
  std::cout &lt;&lt; *it &lt;&lt; endl;
}
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#0aa">int</span>&amp; x : v) { std::cout &lt;&lt; x &lt;&lt; endl; }
<span style="color:#aaa;font-style:italic">//结合auto
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#00a">auto</span>&amp; x : v) { std::cout &lt;&lt; x &lt;&lt; endl; } <span style="color:#aaa;font-style:italic">//reference
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#00a">auto</span> x : v) { std::cout &lt;&lt; x &lt;&lt; endl; }  <span style="color:#aaa;font-style:italic">//copy
</span></code></pre></div><h2 id="8-初始化列表initializer-lists">8. 初始化列表(Initializer lists)</h2>
<p>语法糖，方便对顺序数据结构初始化。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v;
v.push_back(<span style="color:#099">1</span>);
v.push_back(<span style="color:#099">2</span>);
v.push_back(<span style="color:#099">3</span>);
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
std::vector&lt;<span style="color:#0aa">int</span>&gt; v = {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
<span style="color:#aaa;font-style:italic">//自定义初始化列表
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#4c8317">#include</span> <span style="color:#4c8317">&lt;initializer_list&gt;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">myVector</span> {
<span style="color:#00a">public</span>:
  myVector(<span style="color:#00a">const</span> initializer_list&lt;<span style="color:#0aa">int</span>&gt;&amp; v) {
    <span style="color:#00a">for</span> (<span style="color:#00a">auto</span> x : v) _v.push_back(x);
  }
<span style="color:#00a">private</span>:
  std::vector&lt;<span style="color:#0aa">int</span>&gt; _v;
};
myVector mv{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
myVector mv = {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
</code></pre></div><h2 id="9-静态断言static_assert">9. 静态断言(static_assert)</h2>
<p>安全特性，编译器静态检查。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">static_assert</span>( <span style="color:#00a">sizeof</span>(<span style="color:#0aa">int</span>)==<span style="color:#099">4</span>) );
</code></pre></div><h2 id="10-委托构造函数delegating-constructor">10. 委托构造函数(delegating constructor)</h2>
<p>语法糖，向java等语言靠近，方便开发。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Foo</span> {
<span style="color:#00a">public</span>:
  Foo() { init(); }
  Foo(<span style="color:#0aa">int</span> x) { init(); doSomething(x); }
<span style="color:#00a">private</span>:
  <span style="color:#0aa">void</span> init() { <span style="color:#aaa;font-style:italic">//to some init }
</span><span style="color:#aaa;font-style:italic"></span>};
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Foo</span> {
<span style="color:#00a">public</span>:
  Foo() { <span style="color:#aaa;font-style:italic">//to some init }
</span><span style="color:#aaa;font-style:italic"></span>  Foo(<span style="color:#0aa">int</span> x) : Foo() { doSomething(x); } <span style="color:#aaa;font-style:italic">//Foo必须首先被调用
</span><span style="color:#aaa;font-style:italic"></span>};
</code></pre></div><h2 id="11-override关键字">11. override关键字</h2>
<p>安全特性，显示标识函数的”重载“属性，在编译器检查，防止无效重载。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Base</span> {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">int</span> x);
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>() <span style="color:#00a">const</span>;
};

<span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Derived</span> : <span style="color:#00a">public</span> Base {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">float</span> x); <span style="color:#aaa;font-style:italic">//OK, create a new function
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>();        <span style="color:#aaa;font-style:italic">//OK, create a new function
</span><span style="color:#aaa;font-style:italic"></span>};
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Derived</span> : <span style="color:#00a">public</span> Base {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">float</span> x) <span style="color:#00a">override</span>; <span style="color:#aaa;font-style:italic">//Error, no funtion to override
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>() <span style="color:#00a">override</span>;        <span style="color:#aaa;font-style:italic">//Error, no funtion to override
</span><span style="color:#aaa;font-style:italic"></span>};
</code></pre></div><h2 id="12-final关键字">12. final关键字</h2>
<p>安全特性，防止override</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">Base</span>
{
    <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>();
};
 
<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">A</span> : Base
{
    <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>() <span style="color:#00a">final</span>; <span style="color:#aaa;font-style:italic">// Base::foo is overridden and A::foo is the final override
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#0aa">void</span> <span style="color:#0a0">bar</span>() <span style="color:#00a">final</span>; <span style="color:#aaa;font-style:italic">// Error: bar cannot be final as it is non-virtual
</span><span style="color:#aaa;font-style:italic"></span>};
 
<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">B</span> <span style="color:#00a">final</span> : A <span style="color:#aaa;font-style:italic">// struct B is final
</span><span style="color:#aaa;font-style:italic"></span>{
    <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>() <span style="color:#00a">override</span>; <span style="color:#aaa;font-style:italic">// Error: foo cannot be overridden as it is final in A
</span><span style="color:#aaa;font-style:italic"></span>};
 
<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">C</span> : B <span style="color:#aaa;font-style:italic">// Error: B is final
</span><span style="color:#aaa;font-style:italic"></span>{
};
</code></pre></div><h2 id="13-delete与default关键字">13. delete与default关键字</h2>
<p>delete禁用某些成员函数</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">X</span> {
  X&amp; <span style="color:#00a">operator</span>=(<span style="color:#00a">const</span> X&amp;) = <span style="color:#00a">delete</span>;	<span style="color:#aaa;font-style:italic">// Disallow copying
</span><span style="color:#aaa;font-style:italic"></span>  X(<span style="color:#00a">const</span> X&amp;) = <span style="color:#00a">delete</span>;
};
</code></pre></div><p>default恢复默认无参构造函数</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">X</span> {
  X() = <span style="color:#00a">default</span>;
  X(<span style="color:#00a">const</span> X&amp;) {...};
};
</code></pre></div><h2 id="14-nullptr关键字">14. nullptr关键字</h2>
<p>安全特性，防止宏定义<code>NULL</code>的二义性</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>(<span style="color:#0aa">int</span> i);
<span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>(<span style="color:#0aa">void</span>* p);
<span style="color:#aaa;font-style:italic">//c++98 
</span><span style="color:#aaa;font-style:italic"></span>foo(<span style="color:#0aa">NULL</span>); <span style="color:#aaa;font-style:italic">//Error，重载歧义
</span><span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>foo(<span style="color:#00a">nullptr</span>); <span style="color:#aaa;font-style:italic">//OK, 调用void foo(void* p)
</span></code></pre></div><h1 id="参考">参考</h1>
<ol>
<li><a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support, cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories, cppreference.com</a></li>
<li><a href="https://smartbear.com/blog/develop/the-biggest-changes-in-c11-and-why-you-should-care/">The Biggest Changes in C++11 (and Why You Should Care)</a></li>
<li><a href="http://km.oa.com/group/492/articles/show/412065?kmref=search&amp;from_page=1&amp;no=1">《深入浅出 C++ 11 右值引用》, botmanli(李俊宁), 2020, KM</a></li>
</ol>

</main>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script async src="//yihui.name/js/center-img.js"></script>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "Chang Liu" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  
  <hr/>
  © <a href="www.changliu.me">Chang Liu</a> 2020 | <a href="mailto:changliu0828@gmail.com">Contact</a>
  
  </footer>
  </body>
</html>

