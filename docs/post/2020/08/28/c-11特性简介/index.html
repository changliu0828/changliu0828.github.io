<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>c&#43;&#43;11特性简介 | Chang Liu&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">c++11特性简介</span></h1>

<h2 class="date">2020/08/28</h2>
</div>


<aside class="toc">
<nav id="TableOfContents">
  <ul>
    <li><a href="#部分特性与示例">部分特性与示例</a>
      <ul>
        <li><a href="#1-右值引用rvalue-references">1. 右值引用(rvalue references)</a></li>
        <li><a href="#2-移动语义move-semantic">2. 移动语义(move semantic)</a>
          <ul>
            <li><a href="#21-stdmove">2.1. std::move</a></li>
          </ul>
        </li>
        <li><a href="#3-完美转发perfect-forwarding">3. 完美转发(perfect forwarding)</a>
          <ul>
            <li><a href="#31-引用折叠reference-collapsing">3.1. 引用折叠(reference collapsing)</a></li>
            <li><a href="#32-右值引用类型推导">3.2. 右值引用类型推导</a></li>
            <li><a href="#33-stdforward">3.3. std::forward</a></li>
          </ul>
        </li>
        <li><a href="#4-lambda表达式lambda-expressions">4. lambda表达式(lambda expressions)</a></li>
        <li><a href="#5-自动类型推导auto与decltype关键字">5. 自动类型推导(auto)与decltype关键字</a></li>
        <li><a href="#6-基于range的for循环range-based-for">6. 基于range的for循环(range-based for)</a></li>
        <li><a href="#7-初始化列表initializer-lists">7. 初始化列表(Initializer lists)</a></li>
        <li><a href="#8-静态断言static_assert">8. 静态断言(static_assert)</a></li>
        <li><a href="#9-委托构造函数delegating-constructor">9. 委托构造函数(delegating constructor)</a></li>
        <li><a href="#10-override关键字">10. override关键字</a></li>
        <li><a href="#11-final关键字">11. final关键字</a></li>
        <li><a href="#12-delete与default关键字">12. delete与default关键字</a></li>
        <li><a href="#13-nullptr关键字">13. nullptr关键字</a></li>
        <li><a href="#14-std标准库">14. std::标准库</a>
          <ul>
            <li><a href="#141-智能指针">14.1. 智能指针</a></li>
            <li><a href="#142-all_of-any_of-none_of">14.2. all_of, any_of, none_of</a></li>
            <li><a href="#143-stdunordered_map-stdunordered_set">14.3. std::unordered_map, std::unordered_set</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#最后">最后</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
</aside>



<main>
<p>c++自1985年发行以来，以其高效、灵活的特性成为最成功的高级编程语言之一。2011年，距离上一个c++标准c++03发布的8年后，c++委员会吸取了现代编程语言的若干特性，发布了新的c++11标准，使得古朴的c++得以跻身现代编程语言的行列。本文挑选了部分c++11引入的新特性进行说明，阐述其缘由，使用以及注意事项。如果你需要查看完整特性与编译器支持请参考<a href="https://en.cppreference.com/w/cpp/compiler_support">这里$^{[1]}$</a>。</p>
<h1 id="部分特性与示例">部分特性与示例</h1>
<h2 id="1-右值引用rvalue-references">1. 右值引用(rvalue references)</h2>
<p>在C语言中，左值与右值原是极为简单的概念——凡是既可以出现在赋值语句两边的称为左值，只能出现在赋值语句右边的称为右值。例如下面的代码中，<code>a</code>和<code>b</code>是左值，<code>42</code>和<code>a + b</code>是右值。如果右值出现在赋值语句左边，则会如你所熟知的一样，产生一个编译错误。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span> a = <span style="color:#099">42</span>;
<span style="color:#0aa">int</span> b = a;
<span style="color:#099">42</span> = a + b; <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span>a + b = a;  <span style="color:#aaa;font-style:italic">//compile error
</span></code></pre></div><p>另一种区分左值与右值的方法是，左值是哪些能被<code>&amp;</code>操作符取到地址的值，右值是通过左值运算得出的临时结果或一些字面常量。把上面的代码编译成汇编语言就一目了然了。下面的代码中左值<code>a</code>和<code>b</code>都在栈上分配了空间，分别是<code>-4(%rbp)</code>和<code>-8(%rbp)</code>，而右值<code>42</code>是一个立即数，<code>a + b</code>则是<code>addl</code>的两个参数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#0a0">movl</span>  <span style="color:#a00">$42</span>, -<span style="color:#099">4</span>(<span style="color:#a00">%rbp</span>)   <span style="color:#aaa;font-style:italic">;int a = 42;
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#a00">movl</span>  -<span style="color:#099">4</span>(<span style="color:#a00">%rbp</span>), <span style="color:#a00">%eax</span>
<span style="color:#0a0">movl</span>  <span style="color:#a00">%eax</span>, -<span style="color:#099">8</span>(<span style="color:#a00">%rbp</span>)
<span style="color:#0a0">movl</span>  -<span style="color:#099">8</span>(<span style="color:#a00">%rbp</span>), <span style="color:#a00">%eax</span>  <span style="color:#aaa;font-style:italic">;int b = a
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#a00">addl</span>  <span style="color:#a00">%eax</span>, -<span style="color:#099">4</span>(<span style="color:#a00">rbp</span>)<span style="color:#aaa;font-style:italic">;  ;a = a + b
</span></code></pre></div><p>谈过了“右值”，我们来讨论下”引用“。使用引用是提高程序运行效率的常用手段，而在只提供左值引用的C++03时代，在某些场景下的引用并没有那么“好用”。例如下面的代码中，由于无法传递右值<code>Data()</code>的引用，我们不得不使用3行丑陋的代码来完成一个简单的工作。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
Data double_data = Merge(Data(), Data()); <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic">//ok, but ugly
</span><span style="color:#aaa;font-style:italic"></span>Data data1;
Data data2;
Data double_data = Merge(data1, data2);
</code></pre></div><p>为此，C++中，提供了右值引用操作符<code>&amp;&amp;</code>。于是我们保留原先的左值引用版<code>Merge</code>，增加支持右值引用的<code>Merge</code>，代码可以简化成，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
<span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp;&amp; data1, Data&amp;&amp; data2);
Data double_data = Merge(Data(), Data()); <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><p>然而，如果这时候我们想传入一个左值和一个右值，编译器就无法匹配对应的<code>Merge</code>了。此时需要使用<code>std::move</code>将左值<code>data1</code>转化为右值引用，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp; data1, Data&amp; data2);
<span style="color:#00a">extern</span> Data <span style="color:#0a0">Merge</span>(Data&amp;&amp; data1, Data&amp;&amp; data2);
Data data1;
Data double_data = Merge(data1, Data()); <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span>Data double_data = Merge(std::move(data1), Data()); <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><p>在c++03时代，我们可以对右值进行<code>const</code>引用，从而扩展右值的生命周期到引用销毁之时，但缺点是其值<strong>不可被修改</strong>。在c++11中，通过右值引用，我们<strong>不仅可以延长右值的生命周期，其值也可以自由修改</strong>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">const</span> <span style="color:#0aa">int</span>&amp; a = <span style="color:#099">42</span>;
a = <span style="color:#099">43</span>; <span style="color:#aaa;font-style:italic">//compile error
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">int</span>&amp;&amp;b = <span style="color:#099">42</span>;
b = <span style="color:#099">43</span>; <span style="color:#aaa;font-style:italic">//ok
</span></code></pre></div><h2 id="2-移动语义move-semantic">2. 移动语义(move semantic)</h2>
<p>移动语义旨在通过右值引用，实现资源的“移动&rdquo;，而非先拷贝再删除，节省拷贝开销。这里注意，原资源的释放是被要求，但不是必须的。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Data(Data&amp;&amp; other) {
  _res = other._res;
  other._res = <span style="color:#00a">nullptr</span>;
}
</code></pre></div><h3 id="21-stdmove">2.1. std::move</h3>
<p>使用<code>std::move</code>可以将左值转为右值，从而方便使用移动语义。<strong>这里指的注意的是，将左值传入移动构造函数，会导致其值被释放。所以应当确保在调用移动构造后，该左值不被使用。</strong></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">extern</span> Data::Data(<span style="color:#00a">const</span> Data&amp; other);
<span style="color:#00a">extern</span> Data::Data(Data&amp;&amp; other);
Data d1;
Data <span style="color:#0a0">d2</span>(d1); <span style="color:#aaa;font-style:italic">//d1 is lvalue, copy constructor
</span><span style="color:#aaa;font-style:italic"></span>Data <span style="color:#0a0">d2</span>(std::move(d1)); <span style="color:#aaa;font-style:italic">//std::move(d1) is rvalue, move constructor
</span></code></pre></div><p>另外一个值得注意的问题是，有些时候我们以为是一个移动构造，但其实执行的是拷贝构造，例如下面的<code>_str</code>其实执行的是<code>string</code>的拷贝构造，这是因为发生了后文中会提到的<strong>右值引用类型推导</strong>，正确的做法是<code>_str = std::move(other._str)</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Data(Data&amp;&amp; other) {
  _str = other._str;            <span style="color:#aaa;font-style:italic">//copy
</span><span style="color:#aaa;font-style:italic"></span>  _str = std::move(other._str); <span style="color:#aaa;font-style:italic">//correct move
</span><span style="color:#aaa;font-style:italic"></span>}
</code></pre></div><h2 id="3-完美转发perfect-forwarding">3. 完美转发(perfect forwarding)</h2>
<p>在泛型编程中，我们有时候需要”转发“一些参数给其他函数。比较典型的一个例子是传递一个类型和若干构造他的参数。例如下面的代码，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T, <span style="color:#00a">typename</span> ARG1, <span style="color:#00a">typename</span> ARG2&gt;
T* allocate(ARG1 arg1, ARG2 arg2) {
  <span style="color:#00a">return</span> <span style="color:#00a">new</span> <span style="color:#0a0">T</span>(arg1, arg2);
}
</code></pre></div><p>抽象一下，我们需要的是一个包裹函数<code>wrapper</code>来传递参数给<code>func</code>。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp; e1, T2&amp; e2) {
  func(e1, e2);
}
wrapper(<span style="color:#099">42</span>, <span style="color:#099">10</span>);  <span style="color:#aaa;font-style:italic">//compile error
</span></code></pre></div><p>在上面的代码中，我们使用引用来传递参数以提高效率，这正是我们以前习惯的“伎俩”。然而，使用左值引用的<code>wrapper</code>对右值无能为力。为此，对于两个参数<code>T1</code>和<code>T2</code>，我们需要分别支持左值引用和右值引用的<code>wrapper</code>函数，也就是4个<code>wrapper</code>，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp; e1, T2&amp; e2) { func(e1, e2); }

<span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp; e1, T2&amp;&amp; e2) { func(e1, e2); }

<span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp;&amp; e1, T2&amp; e2) { func(e1, e2); }

<span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp;&amp; e1, T2&amp;&amp; e2) { func(e1, e2); }
</code></pre></div><p>灾难发生了，对于$n$个参数的函数来讲，需要$2^n$个特例来接受所有可能性。更可怕的是，c++11提供了可变参数模板！那我们有没有办法在<strong>保持值类型不变进行转发</strong>呢？完美转发正是我们想要的答案。</p>
<h3 id="31-引用折叠reference-collapsing">3.1. 引用折叠(reference collapsing)</h3>
<p>在介绍完美转发之前，我想有必要先阐释下引用折叠。请首先思考一下，在下面的例子中，<code>r</code>的类型分别会是什么？</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span>&lt;<span style="color:#00a">typename</span> T&gt;
<span style="color:#0aa">void</span> wrapper(T t) {
 T&amp; r = t;
}
<span style="color:#0aa">int</span> a = <span style="color:#099">42</span>;
wrapper&lt;<span style="color:#0aa">int</span>&amp;&gt;(a);
wrapper&lt;<span style="color:#0aa">int</span>&amp;&amp;&gt;(<span style="color:#099">42</span>);
</code></pre></div><p>对于“引用的引用”，c++11中给出了明确的解析方式，我们称之为引用折叠(reference collapsing)。具体的规则为：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">&amp; &amp; -&gt; &amp;
&amp;&amp; &amp; -&gt; &amp;
&amp; &amp;&amp; -&gt; &amp;
&amp;&amp; &amp;&amp; -&gt; &amp;&amp;
</code></pre></div><p>我们可以简单记忆为，在有左值引用的<code>&amp;</code>的情况下，最终的值类型一定是左值引用。</p>
<h3 id="32-右值引用类型推导">3.2. 右值引用类型推导</h3>
<p>另外值得一提的是，在模板函数的形参为右值引用时，形参的类型取决于传入的实参类型。具体来说，我们分析下面的代码中形参<code>t</code>的类型。当传入类型左值类型<code>U</code>时，<code>t</code>的类型为<code>U&amp;</code>。传入右值类型<code>U</code>时，<code>t</code>的类型为<code>U</code>。这既是右值引用类型推导规则。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span> &lt;<span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">T</span>&gt; <span style="color:#0aa">void</span> func(T&amp;&amp; t) {}
func(<span style="color:#099">42</span>);           <span style="color:#aaa;font-style:italic">// 42 is an rvalue: T deduced to int
</span><span style="color:#aaa;font-style:italic"></span>
<span style="color:#0aa">double</span> d = <span style="color:#099">3.14</span>;
func(d);            <span style="color:#aaa;font-style:italic">// d is an lvalue; T deduced to double&amp;
</span></code></pre></div><h3 id="33-stdforward">3.3. std::forward</h3>
<p>那么回到我们的<code>wrapper</code>函数。在c++11中，对它进行完美转发的正确写法应该是下面的代码。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span> &lt;<span style="color:#00a">typename</span> T1, <span style="color:#00a">typename</span> T2&gt;
<span style="color:#0aa">void</span> wrapper(T1&amp;&amp; e1, T2&amp;&amp; e2) {
    func(std::forward&lt;T1&gt;(e1), std::forward&lt;T2&gt;(e2));
}
</code></pre></div><p>其中<code>std::forward</code>的实现为，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">template</span>&lt;<span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">T</span>&gt;
T&amp;&amp; forward(<span style="color:#00a">typename</span> std::remove_reference&lt;T&gt;::type&amp; t) <span style="color:#00a">noexcept</span> {
  <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;T&amp;&amp;&gt;(t);
}
<span style="color:#00a">template</span> &lt;<span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">T</span>&gt;
T&amp;&amp; forward(<span style="color:#00a">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; t) <span style="color:#00a">noexcept</span> {
  <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;T&amp;&amp;&gt;(t);
}
</code></pre></div><p>如果我们如下使用wrapper，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span> a = <span style="color:#099">42</span>;
wrapper(a, <span style="color:#099">1.0f</span>);
</code></pre></div><p>实参<code>a</code>的形参<code>e1</code>的类型为<code>int&amp;</code>，所以forward特例化为如下代码，保留了左值引用类型。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span>&amp; &amp;&amp; forward(<span style="color:#0aa">int</span>&amp; t) <span style="color:#00a">noexcept</span> { <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;<span style="color:#0aa">int</span>&amp; &amp;&amp;&gt;(t); }
</code></pre></div><p>引用折叠后，即，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span>&amp; forward(<span style="color:#0aa">int</span>&amp; t) <span style="color:#00a">noexcept</span> { <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;<span style="color:#0aa">int</span>&amp;&gt;(t); }
</code></pre></div><p>实参<code>42</code>的形参<code>e2</code>的类型为<code>int&amp;&amp;</code>，所以forward特例化为如下代码，保留了右值引用类型。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span>&amp;&amp; &amp;&amp; forward(<span style="color:#0aa">int</span>&amp;&amp; t) <span style="color:#00a">noexcept</span> { <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;<span style="color:#0aa">int</span>&amp;&amp; &amp;&amp;&gt;(t); }
</code></pre></div><p>引用折叠后，即，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span>&amp;&amp; forward(<span style="color:#0aa">int</span>&amp;&amp; t) <span style="color:#00a">noexcept</span> { <span style="color:#00a">return</span> <span style="color:#00a">static_cast</span>&lt;<span style="color:#0aa">int</span>&amp;&amp;&gt;(t); }
</code></pre></div><p>至此，c++11通过引用折叠与右值引用类型推导实现了完美转发。</p>
<h2 id="4-lambda表达式lambda-expressions">4. lambda表达式(lambda expressions)</h2>
<p>lambda表达式使得我们可以更加优雅的实现一些“只需要使用一次”的函数。例如<code>std::sort</code>中常用的比较函数，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">Point</span> {
  <span style="color:#0aa">int</span> x;
  <span style="color:#0aa">int</span> y;
};
vector&lt;Point&gt; v;
<span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">int</span> <span style="color:#0a0">compByX</span>(<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.x &lt; p2.x; }
<span style="color:#0aa">int</span> <span style="color:#0a0">compByY</span>(<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.y &lt; p2.y; }
sort(v.begin, v.end(), compByX);
sort(v.begin, v.end(), compByY);
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>sort(v.begin, v.end(), [](<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.x &lt; p2.x });
sort(v.begin, v.end(), [](<span style="color:#00a">const</span> Point&amp; p1, <span style="color:#00a">const</span> Point&amp; p1) { <span style="color:#00a">return</span> p1.y &lt; p2.y });
</code></pre></div><h2 id="5-自动类型推导auto与decltype关键字">5. 自动类型推导(auto)与decltype关键字</h2>
<p>与其他现代高级语言一样，<code>auto</code>为强类型语言实现了类似于脚本语言的自动类型推导功能。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">for</span> (<span style="color:#00a">auto</span> it = v.begin(); it != v.end(); ++ it) {
  std::cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre></div><p><code>decltype</code>则提供了编译期的自动类型推导。如果你不想执行某个表达式，又想得到它的类型，那请使用<code>decltype</code>，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">decltype</span>(a+b) c;
</code></pre></div><h2 id="6-基于range的for循环range-based-for">6. 基于range的for循环(range-based for)</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">for</span> (<span style="color:#0aa">int</span>&amp; x : v) { std::cout &lt;&lt; x &lt;&lt; endl; }
<span style="color:#aaa;font-style:italic">//结合auto
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#00a">auto</span>&amp; x : v) { std::cout &lt;&lt; x &lt;&lt; endl; } <span style="color:#aaa;font-style:italic">//reference
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">for</span> (<span style="color:#00a">auto</span> x : v) { std::cout &lt;&lt; x &lt;&lt; endl; }  <span style="color:#aaa;font-style:italic">//copy
</span></code></pre></div><h2 id="7-初始化列表initializer-lists">7. 初始化列表(Initializer lists)</h2>
<p>语法糖，方便对顺序数据结构初始化。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v;
v.push_back(<span style="color:#099">1</span>);
v.push_back(<span style="color:#099">2</span>);
v.push_back(<span style="color:#099">3</span>);
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>std::vector&lt;<span style="color:#0aa">int</span>&gt; v{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
std::vector&lt;<span style="color:#0aa">int</span>&gt; v = {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
<span style="color:#aaa;font-style:italic">//自定义初始化列表
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#4c8317">#include</span> <span style="color:#4c8317">&lt;initializer_list&gt;</span><span style="color:#4c8317">
</span><span style="color:#4c8317"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">myVector</span> {
<span style="color:#00a">public</span>:
  myVector(<span style="color:#00a">const</span> initializer_list&lt;<span style="color:#0aa">int</span>&gt;&amp; v) {
    <span style="color:#00a">for</span> (<span style="color:#00a">auto</span> x : v) _v.push_back(x);
  }
<span style="color:#00a">private</span>:
  std::vector&lt;<span style="color:#0aa">int</span>&gt; _v;
};
myVector mv{<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
myVector mv = {<span style="color:#099">1</span>,<span style="color:#099">2</span>,<span style="color:#099">3</span>};
</code></pre></div><h2 id="8-静态断言static_assert">8. 静态断言(static_assert)</h2>
<p>安全特性，编译器静态检查。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">static_assert</span>( <span style="color:#00a">sizeof</span>(<span style="color:#0aa">int</span>)==<span style="color:#099">4</span>) );
</code></pre></div><h2 id="9-委托构造函数delegating-constructor">9. 委托构造函数(delegating constructor)</h2>
<p>语法糖，方便简化类的初始化行为。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Foo</span> {
<span style="color:#00a">public</span>:
  Foo() { init(); }
  Foo(<span style="color:#0aa">int</span> x) { init(); doSomething(x); }
<span style="color:#00a">private</span>:
  <span style="color:#0aa">void</span> init() { <span style="color:#aaa;font-style:italic">//to some init }
</span><span style="color:#aaa;font-style:italic"></span>};
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Foo</span> {
<span style="color:#00a">public</span>:
  Foo() { <span style="color:#aaa;font-style:italic">//to some init }
</span><span style="color:#aaa;font-style:italic"></span>  Foo(<span style="color:#0aa">int</span> x) : Foo() { doSomething(x); } <span style="color:#aaa;font-style:italic">//Foo必须首先被调用
</span><span style="color:#aaa;font-style:italic"></span>};
</code></pre></div><h2 id="10-override关键字">10. override关键字</h2>
<p>安全特性，显示标识函数的”重载“属性，在编译器检查，防止无效重载。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Base</span> {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">int</span> x);
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>() <span style="color:#00a">const</span>;
};

<span style="color:#aaa;font-style:italic">//c++03
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Derived</span> : <span style="color:#00a">public</span> Base {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">float</span> x); <span style="color:#aaa;font-style:italic">//OK, create a new function
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>();        <span style="color:#aaa;font-style:italic">//OK, create a new function
</span><span style="color:#aaa;font-style:italic"></span>};
<span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">Derived</span> : <span style="color:#00a">public</span> Base {
  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">A</span>(<span style="color:#0aa">float</span> x) <span style="color:#00a">override</span>; <span style="color:#aaa;font-style:italic">//Error, no funtion to override
</span><span style="color:#aaa;font-style:italic"></span>  <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">B</span>() <span style="color:#00a">override</span>;        <span style="color:#aaa;font-style:italic">//Error, no funtion to override
</span><span style="color:#aaa;font-style:italic"></span>};
</code></pre></div><h2 id="11-final关键字">11. final关键字</h2>
<p>提供了防止override的能力。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">Base</span> {
    <span style="color:#00a">virtual</span> <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>();
};

<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">A</span> : Base {
    <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>() <span style="color:#00a">final</span>; <span style="color:#aaa;font-style:italic">// Base::foo is overridden and A::foo is the final override
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#0aa">void</span> <span style="color:#0a0">bar</span>() <span style="color:#00a">final</span>; <span style="color:#aaa;font-style:italic">// Error: bar cannot be final as it is non-virtual
</span><span style="color:#aaa;font-style:italic"></span>};

<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">B</span> <span style="color:#00a">final</span> : A { <span style="color:#aaa;font-style:italic">// struct B is final
</span><span style="color:#aaa;font-style:italic"></span>{
    <span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>() <span style="color:#00a">override</span>; <span style="color:#aaa;font-style:italic">// Error: foo cannot be overridden as it is final in A
</span><span style="color:#aaa;font-style:italic"></span>};

<span style="color:#00a">struct</span> <span style="color:#0a0;text-decoration:underline">C</span> : B { <span style="color:#aaa;font-style:italic">// Error: B is final
</span><span style="color:#aaa;font-style:italic"></span>};
</code></pre></div><h2 id="12-delete与default关键字">12. delete与default关键字</h2>
<p>提供了禁用某些成员函数的能力。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">X</span> {
  X&amp; <span style="color:#00a">operator</span>=(<span style="color:#00a">const</span> X&amp;) = <span style="color:#00a">delete</span>;	<span style="color:#aaa;font-style:italic">// Disallow copying
</span><span style="color:#aaa;font-style:italic"></span>  X(<span style="color:#00a">const</span> X&amp;) = <span style="color:#00a">delete</span>;
};
</code></pre></div><p>default恢复默认无参构造函数</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">X</span> {
  X() = <span style="color:#00a">default</span>;
  X(<span style="color:#00a">const</span> X&amp;) {...};
};
</code></pre></div><h2 id="13-nullptr关键字">13. nullptr关键字</h2>
<p>安全特性，防止宏定义<code>NULL</code>的二义性</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>(<span style="color:#0aa">int</span> i);
<span style="color:#0aa">void</span> <span style="color:#0a0">foo</span>(<span style="color:#0aa">void</span>* p);
<span style="color:#aaa;font-style:italic">//c++98
</span><span style="color:#aaa;font-style:italic"></span>foo(<span style="color:#0aa">NULL</span>); <span style="color:#aaa;font-style:italic">//Error，重载歧义
</span><span style="color:#aaa;font-style:italic">//c++11
</span><span style="color:#aaa;font-style:italic"></span>foo(<span style="color:#00a">nullptr</span>); <span style="color:#aaa;font-style:italic">//OK, 调用void foo(void* p)
</span></code></pre></div><h2 id="14-std标准库">14. std::标准库</h2>
<h3 id="141-智能指针">14.1. 智能指针</h3>
<p>为了防止使用指针过程中的空指针，野指针等常见为题，c++11增加了三种智能指针.</p>
<h4 id="unique_ptr">unique_ptr</h4>
<p>保证了资源的“独占使用”，在任意时刻只能有一个unique_ptr指向资源。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">unique_ptr&lt;string&gt; p1(<span style="color:#00a">new</span> string (<span style="color:#a50">&#34;Hello&#34;</span>));
unique_ptr&lt;string&gt; p2 = p1; <span style="color:#aaa;font-style:italic">//error
</span></code></pre></div><p>我们可以使用<code>release</code>和<code>reset</code>方法来转移资源的所有权，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">unique_ptr&lt;string&gt; pu2.reset(p1.release());
</code></pre></div><p>此外，我们可以赋值和拷贝一个将要销毁的<code>unique_ptr</code>，例如，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">unique_ptr&lt;string&gt; func() {}
unique_ptr&lt;string&gt; p1 = func();
</code></pre></div><h4 id="shared_ptr">shared_ptr</h4>
<p>通过引用计数实现了资源的自动释放。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">shared_ptr&lt;string&gt; ps1(<span style="color:#00a">new</span> string (<span style="color:#a50">&#34;Hello&#34;</span>)); <span style="color:#aaa;font-style:italic">//ps1.use_count() = 1
</span><span style="color:#aaa;font-style:italic"></span>ps2 = ps1;  <span style="color:#aaa;font-style:italic">//ps1.use_count() = 2
</span></code></pre></div><p>在使用时，我们需要注意禁止使用指针给智能指针赋值。下面的代码中，<code>p1</code>和<code>p2</code>分别维护引用计数，当资源释放时，会导致重复析构。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#0aa">int</span> *a = <span style="color:#00a">new</span> <span style="color:#0aa">int</span>(<span style="color:#099">42</span>);
shared_ptr&lt;<span style="color:#0aa">int</span>&gt; p1(a);
shared_ptr&lt;<span style="color:#0aa">int</span>&gt; p2(a);
</code></pre></div><p>此外，<code>shared_ptr</code>在使用中存在循环引用问题，如下代码展示了这一情况，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">A</span> {
  shared_ptr&lt;B&gt; _p;
<span style="color:#00a">public</span>:
  setP(shared_ptr&lt;B&gt;&amp; p) { _p = p };
};
<span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">B</span> {
  shared_ptr&lt;A&gt; _p;
<span style="color:#00a">public</span>:
  setP(shared_ptr&lt;A&gt;&amp; p) { _p = p };
};

shared_ptr&lt;A&gt; pA(<span style="color:#00a">new</span> A);
shared_ptr&lt;A&gt; pB(<span style="color:#00a">new</span> B);
pA-&gt;setP(pB);
pB-&gt;setP(pA);
</code></pre></div><h4 id="weak_ptr">weak_ptr</h4>
<p>解决<code>shared_ptr</code>循环引用问题，与<code>shared_ptr</code>配合使用，不占用引用计数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">A</span> {
  weak_ptr&lt;B&gt; _p;
<span style="color:#00a">public</span>:
  setP(weak_ptr&lt;B&gt;&amp; p) { _p = p };
};
<span style="color:#00a">class</span> <span style="color:#0a0;text-decoration:underline">B</span> {
  weak_ptr&lt;A&gt; _p;
<span style="color:#00a">public</span>:
  setP(weak_ptr&lt;A&gt;&amp; p) { _p = p };
};

shared_ptr&lt;A&gt; pA(<span style="color:#00a">new</span> A);
shared_ptr&lt;A&gt; pB(<span style="color:#00a">new</span> B);
pA-&gt;setP(pB);
pB-&gt;setP(pA);
</code></pre></div><h3 id="142-all_of-any_of-none_of">14.2. all_of, any_of, none_of</h3>
<p>如下例，</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">all_of(v.begin(), v.end(), ispositive());
any_of(v.begin(), v.end(), ispositive());
none_of(v.begin(), v.end(), ispositive());
</code></pre></div><h3 id="143-stdunordered_map-stdunordered_set">14.3. std::unordered_map, std::unordered_set</h3>
<p>与<code>std::map</code>和<code>std::set</code>使用发放类似，以哈希表作为底层实现，提供$ O(1) $的插入查询效率。哈希表的负载因子(LoadFactor)超过阈值时，会自动进行rehashing，进而可能导致迭代器失效。</p>
<h1 id="最后">最后</h1>
<p>在2020年，虽然最新的标准已经来到了c++20，但c++11依然具有学习的意义。在我看来其可以视为是c++迈向现代编程语言的最重要一步，也是承上启下的一个关键性版本。</p>
<p>最后，感谢你的阅读。如果你觉得本文有任何错误，亦或是你有任何疑虑和感想，请一定<a href="mailto:changliu0828@gmail.com">让我知道</a>。</p>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler support, cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/value_category">Value categories, cppreference.com</a></li>
<li><a href="https://smartbear.com/blog/develop/the-biggest-changes-in-c11-and-why-you-should-care/">The Biggest Changes in C++11 (and Why You Should Care)</a></li>
<li><a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c">Perfect forwarding and universal references in C++</a></li>
</ol>

</main>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  © <a href="www.changliu.me">Chang Liu</a> 2020 | <a href="mailto:changliu0828@gmail.com">Contact</a>
  
  </footer>
  </body>
</html>

