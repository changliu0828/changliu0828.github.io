<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dijstra&#39;s mutual exclusion algorithm | Chang Liu&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h2><span class="title">Dijstra&rsquo;s mutual exclusion algorithm</span></h2>

<h3 class="date">2020/09/03</h3>
</div>




<main>
<p><a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a>于1965年发表文章<a href="https://www.di.ens.fr/~pouzet/cours/systeme/bib/dijkstra.pdf">Solution of a Problem in Concurrent Programming Control</a>，引出并发系统下的互斥(mutual exclusion)问题，自此开辟了分布式计算领域。Dijkstra在文中给出了基于共享存储原子性访问的解决方案只有十多行代码，但阅读起来较难以理解。在查阅若干资料后，总结了一种较为直观的解释方法，记录于此。</p>
<h1 id="问题">问题</h1>
<p>考虑N个节点(进程)，每个都在运行一个无限循环的程序。每轮循环当中都存在一个临界区(critical section)。我们需要设计算法控制多个计算机中，同时只有一台可以进入其临界区，并需要满足下列条件，</p>
<ol>
<li>所有的节点是对称(symmetrical)的，即我们不能引入类似于“1号节点优先于2号节点”的静态优先级配置。</li>
<li>各个节点的运行速度可能不同，同一个节点在不同时刻的运行速度也可能不同。</li>
<li>任意节点在临界区外停止运行，不应引起系统的死锁。</li>
<li>如果多个节点想要访问临界区，必须在有限时间内决策出哪个节点优先访问。</li>
</ol>
<p>各个节点之间可以通过共享存储(common store)通信，共享存储提供以字(word)为单位的原子性读写。</p>
<p><img src="/image/Solution-of-a-Problem-in-Concurrent-Programming-Control/problem.png" alt="problem"></p>
<p>当今现在，在基于共享内存通信的单机多进程上，我们可以很方便的使用基于TAS(Test&amp;Set)或的CAS(Copy&amp;Swap)实现的互斥锁mutex来实现临界区互斥访问。然而，在只有对内存单元原子读写的条件下，如何完成互斥访问呢？Dijkstra给出了他的解法。</p>
<h1 id="解法与证明">解法与证明</h1>
<p>在共享存储上，Dijkstra使用了如下数据，</p>
<blockquote>
<p>Boolean array b, c[1:N]; integer K</p>
</blockquote>
<p>其中，$k$ 满足 $1 \leqslant k \leqslant N$，$b[i]$ 和 $c[i]$ 只被节点 $i$ 修改，且初始值为true。对于第 $i$ 个节点$(1 \leqslant i \leqslant N)$，执行下面的代码</p>
<pre><code class="language-pascal" data-lang="pascal">integer j
Li0:  b[i] := false
Li1:  if k != i then
Li2:  begin c[i] := true
Li3:  if b[k] then k := i
      go to Li1
      end
        else
Li4:  begin c[i] := false
        for j := 1 step 1 until N do
          if j != i and not c[j] then go to Li1
      end
      critical section;
      c[i] := true; b[i] := true
      remainder of the cycle in which stopping is allowed;
      go to Li0
</code></pre><p>Dijkstra原文中给出的证明集中论证两点。第一，所有节点互斥访问临界区。第二，不会出现系统死锁。建议大家可以先结合代码看下原文中证明。</p>
<h1 id="易读版本">易读版本</h1>
<p>在此，我为了便于理解，对原代码做了如下修改，</p>
<ul>
<li>修改为c语言版本</li>
<li>将数组和节点下标修改为通用的 $0,1, &hellip;, N-1$。</li>
<li>将数组 <code>b</code> 改名为 <code>apply_enter_critical_section</code>，数组 <code>c</code> 改名为 <code>in_critical_section</code>。</li>
<li>将 <code>b</code> 和 <code>c</code> 数组的初始值改为 <code>false</code> ，并翻转代码中所有的布尔值，即 <code>false</code> 改为 <code>true</code>, <code>true</code> 改为 <code>false</code> 。</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#0aa">bool</span> want_to_enter_critical_section[N] = { <span style="color:#0aa">false</span> }; <span style="color:#aaa;font-style:italic">//b array
</span><span style="color:#aaa;font-style:italic"></span><span style="color:#0aa">bool</span> in_critical_section[N] = { <span style="color:#0aa">false</span> };            <span style="color:#aaa;font-style:italic">//c array
</span><span style="color:#aaa;font-style:italic"></span>Li0: want_to_enter_critical_section[i] = <span style="color:#0aa">true</span>;
Li1:<span style="color:#00a">if</span> (k != i) {
Li2:    in_critical_section[i] = <span style="color:#0aa">false</span>;
Li3:    <span style="color:#00a">if</span> (!want_to_enter_critical_section[k]) k = i;
        <span style="color:#00a">goto</span> Li1;
Li4:} <span style="color:#00a">else</span> {
        in_critical_section[i] = <span style="color:#0aa">true</span>;
        <span style="color:#00a">for</span> (<span style="color:#0aa">int</span> j = <span style="color:#099">0</span>; j &lt; N; ++ j)
            <span style="color:#00a">if</span> (j != i &amp;&amp; in_critical_section[j]) <span style="color:#00a">goto</span> Li1;
    }
    <span style="color:#aaa;font-style:italic">//critical section;
</span><span style="color:#aaa;font-style:italic"></span>    in_critical_section[i] = <span style="color:#0aa">false</span>; want_to_enter_critical_section[i] = <span style="color:#0aa">false</span>;
    <span style="color:#aaa;font-style:italic">//remainder of the cycle in which stopping is allowed;
</span><span style="color:#aaa;font-style:italic"></span>    <span style="color:#00a">goto</span> Li0;
</code></pre></div><p><strong>证明：</strong></p>
<p><strong>1. mutual exclusion</strong></p>
<p>如果程序想运行到critical section，则必须运行通过 <code>Li4</code> 中的代码且不返回 <code>Li1</code> 。即，除了自身的 <code>in_critical_section[i]</code> 为 <code>true</code> 外，其余所有节点的 <code>in_critical_section[i]</code> 均为 <code>false</code> 。</p>
<p><strong>2. non-blocking</strong></p>
<p>如果第 $k$ 个节点不在 <code>Li0~Li4</code> 的循环中，则 <code>want_to_enter_critical_section</code> 为 <code>false</code>。所有在循环中的节点会在 <code>Li1</code> 判定 <code>(k != i)</code>，其中的一个或多个节点会执行到 <code>Li3</code> ，其中某个节点将设定 <code>k = i</code>。此后 <code>want_to_enter_critical_section[k]</code> 为 <code>true</code>，其他节点无法再更改 <code>k</code> ，直至第14行将 <code>want_to_enter_critical_section[k]</code> 为 <code>false</code>。</p>
<p>在 <code>k</code> 被确定后，第k个节点会不断尝试 <code>Li4</code> 中的代码，直至其余所有的<code>in_critical_section[i]</code> 全部为 <code>false</code>。这种情况必然会发生，不论临界区中的节点离开临界区，还是临界区外的发现 <code>Li1: k != i</code>，都会执行 <code>in_critical_section[i] = false;</code>。</p>
<p>证毕。</p>
<p><strong>并发情况</strong></p>
<p>这里Dijstra原文中没有明确指出的是，考虑并发情况下两个节点 <code>x</code> 和 <code>y</code> 同时运行 <code>Li4</code> 中代码，则会出现下面的情况。此种情况下，两个节点都 <code>goto Li1</code>。<code>x</code> 和 <code>y</code> 中不等于 <code>k</code>的节点会执行 <code>Li2</code>，从而使得节点 <code>k</code>在下次执行 <code>Li4</code> 时成功通过，进入临界区。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#aaa;font-style:italic">// xyxy, 同xyyx
</span><span style="color:#aaa;font-style:italic"></span>x: in_critical_section[x] = <span style="color:#0aa">true</span>;
y: in_critical_section[y] = <span style="color:#0aa">true</span>;
x: in_critical_section[y] == <span style="color:#0aa">true</span> <span style="color:#00a">goto</span> Li1;
y: in_critical_section[x] == <span style="color:#0aa">true</span> <span style="color:#00a">goto</span> Li1;
</code></pre></div><h1 id="最后">最后</h1>
<p>谢谢你的阅读。如果你读过本文后有任何的思考或疑虑，请务必<a href="mailto:changliu0828@gmail.com">让我知道</a>。</p>

</main>

<div class="post-comment">
    
</div>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  © <a href="www.changliu.me">Chang Liu</a> 2020 | <a href="mailto:changliu0828@gmail.com">Contact</a>
  
  </footer>
  </body>
</html>

